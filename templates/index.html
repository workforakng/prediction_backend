<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>WinGo 1-Min Lottery Prediction Dashboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet" />
<style>
  /* --- Global Styles & Reset --- */
  :root {
    --primary-bg: #f5f7fa;
    --card-bg: #ffffff;
    --header-bg: #1e3a8a;
    --header-text: #ffffff;
    --primary-color: #2563eb;
    --secondary-color: #f59e0b;
    --text-color: #1f2937;
    --subtle-text: #6b7280;
    --border-color: #e5e7eb;
    --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  }

  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Poppins', sans-serif;
    background: var(--primary-bg);
    color: var(--text-color);
    line-height: 1.6;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }

  /* --- Layout & Structure --- */
  .dashboard-header-container {
    position: sticky;
    top: 0;
    z-index: 1000;
  }

  .dashboard-header {
    background: var(--header-bg);
    color: var(--header-text);
    padding: 1.2rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: var(--shadow-md);
  }

  .dashboard-title {
    font-size: 1.6rem;
    font-weight: 700;
    letter-spacing: 1px;
  }

  .top-meta {
    text-align: right;
    font-size: 0.9rem;
    font-weight: 500;
  }
  .top-meta .label {
    color: #9ca3af;
  }
  .top-meta .value {
    color: var(--header-text);
  }
  .top-meta #countdown-timer {
    font-weight: 700;
    font-size: 1.1rem;
    color: var(--secondary-color);
    margin-top: 0.3rem;
  }
  
  main {
    flex: 1;
    max-width: 1200px;
    margin: 0 auto;
    padding: 1.5rem 1rem;
    width: 100%;
  }
  
  h2, .section-title {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--text-color);
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .section {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: var(--shadow-md);
    border: 1px solid var(--border-color);
  }
  
  .grid-container {
    display: grid;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
  }
  
  .grid-2 {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }
  
  .flex-row {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    align-items: center;
  }

  /* --- Prediction & Data Display --- */
  .prediction-numbers {
    display: flex;
    gap: 0.8rem;
    margin-top: 1rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .number-bubble {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    font-size: 2.2rem;
    color: white;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    border: 2px solid transparent;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .number-bubble:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.25);
  }
  .number-bubble.red { background-color: #ef4444; border-color: #b91c1c; }
  .number-bubble.green { background-color: #22c55e; border-color: #166534; }
  .number-bubble.violet { background-color: #8b5cf6; border-color: #5b21b6; }
  
  .bubble-pct {
    font-size: 0.8rem;
    font-weight: 500;
    color: rgba(255,255,255,0.9);
    margin-top: -5px;
  }

  .info-block {
    text-align: center;
  }
  .info-block-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--subtle-text);
    margin-bottom: 0.5rem;
  }
  .info-block-content {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--text-color);
  }
  .info-block-content.color-pred, .info-block-content.size-pred {
    font-size: 2.5rem;
    padding: 1rem 2rem;
    border-radius: 12px;
    color: white;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    box-shadow: var(--shadow-md);
  }
  .info-block-content.Red { background-color: #ef4444; }
  .info-block-content.Green { background-color: #22c55e; }
  .info-block-content.Violet { background-color: #8b5cf6; }
  .info-block-content.Big { background-color: #f97316; }
  .info-block-content.Small { background-color: #3b82f6; }
  .info-block-content.Pending { background-color: #d1d5db; color: #4b5563; }

  .meta-text {
    font-size: 0.9rem;
    color: var(--subtle-text);
    margin-top: 0.8rem;
    line-height: 1.4;
  }
  .meta-text strong {
    color: var(--text-color);
    font-weight: 600;
  }
  
  .chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.2em 0.8em;
    border-radius: 9999px;
    font-size: 0.85rem;
    font-weight: 600;
    margin-right: 0.4em;
    margin-bottom: 0.2em;
    vertical-align: middle;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .chip.red { background: #e53935; color: #fff; }
  .chip.green { background: #4caf50; color: #fff; }
  .chip.violet { background: #9c27b0; color: #fff; }
  .chip.gray { background: #bdbdbd; color: #333; }
  .chip.blue { background: #2196f3; color: #fff; }
  .chip.gold { background: #ffc107; color: #333; }

  .chip.Result-Green { background-color: #4caf50; color: #fff; }
  .chip.Result-Red { background-color: #e53935; color: #fff; }
  .chip.Result-Violet { background-color: #9c27b0; color: #fff; }
  .chip.Result-Pending { background-color: #bdbdbd; color: #333; }
  .chip.Result-Big { background-color: #ff9800; color: #fff; }
  .chip.Result-Small { background-color: #3f51b5; color: #fff; }

  /* --- AI Prediction Section --- */
  #ai-prediction-section {
    background-color: #ecfdf5;
    border-color: #a7f3d0;
  }
  #ai-prediction-value {
    font-size: 4rem;
    font-weight: 800;
    margin: 0;
    color: #065f46;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
  }
  #ai-prediction-value.red { color: #dc2626; }
  #ai-prediction-value.green { color: #16a34a; }
  #ai-prediction-value.violet { text-shadow: 0 0 10px #7e22ce; }
  #ai-prediction-meta {
    margin-top: 0.5rem;
    font-size: 0.85rem;
    color: #4b5563;
  }
  #ai-prediction-meta strong { color: #1f2937; }

  /* --- Accuracy & Streaks --- */
  .performance-stats-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }
  .stat-card {
    background: #f9fafb;
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
    border: 1px solid var(--border-color);
  }
  .stat-label {
    font-size: 0.85rem;
    color: var(--subtle-text);
  }
  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-color);
  }
  .win-streak-value { color: #22c55e; }
  .loss-streak-value { color: #ef4444; }

  .streak-row {
    font-size: 0.9rem;
    color: var(--subtle-text);
  }
  .streak-row strong {
    font-weight: 600;
  }

  /* --- Tables --- */
  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
    font-size: 0.9rem;
  }
  thead {
    background: var(--primary-color);
    color: var(--header-text);
  }
  th, td {
    padding: 0.8rem 0.5rem;
    text-align: center;
    border-bottom: 1px solid var(--border-color);
  }
  tbody tr:nth-child(even) { background-color: #f9fafb; }
  tbody tr:hover { background-color: #f3f4f6; }
  .table-scroll {
    overflow-x: auto;
  }
  
  .correct { color: #16a34a; font-weight: 700; }
  .incorrect { color: #dc2626; font-weight: 700; }

  /* --- Buttons & Inputs --- */
  .button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 0.8rem;
  }
  .btn {
    font-family: 'Poppins', sans-serif;
    padding: 0.6rem 1.2rem;
    font-size: 0.9rem;
    font-weight: 600;
    border-radius: 8px;
    cursor: pointer;
    border: none;
    transition: background-color 0.2s, transform 0.1s;
    box-shadow: var(--shadow-sm);
  }
  .btn-primary {
    background-color: var(--primary-color);
    color: white;
  }
  .btn-primary:hover {
    background-color: #1d4ed8;
  }
  .btn-primary:active {
    transform: translateY(1px);
  }

  .btn-ai {
    background-color: #fef08a;
    color: #4c4217;
    font-weight: 700;
    border: 1px solid #fde047;
  }
  .btn-ai.active {
    background-color: #facc15;
    color: #1e3a8a;
  }

  #copy-json-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
    background: #4b5563;
    color: white;
    border-radius: 6px;
    border: none;
    cursor: pointer;
  }

  /* --- Raw Data Section --- */
  .raw-data-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  #raw-json-dropdown {
    font-family: 'Poppins', sans-serif;
    font-size: 0.9rem;
    padding: 0.5rem 0.8rem;
    border-radius: 8px;
    border: 1px solid var(--border-color);
  }
  .raw-json-display {
    background: #1f2937;
    color: #e5e7eb;
    font-family: 'Roboto Mono', monospace;
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    max-height: 400px;
    position: relative;
    white-space: pre-wrap;
    word-break: break-all;
    font-size: 0.8rem;
    line-height: 1.4;
  }
  
  /* --- Status & Messages --- */
  .status-message {
    text-align: center;
    font-size: 0.9rem;
    padding: 0.5rem;
    border-radius: 8px;
    margin: 0.5rem 0;
  }
  .status-message.success {
    color: #166534;
    background-color: #dcfce7;
  }
  .status-message.error {
    color: #991b1b;
    background-color: #fee2e2;
  }
  .status-message.info {
    color: #1d4ed8;
    background-color: #dbeafe;
  }

  /* --- Mobile Adjustments --- */
  @media (max-width: 768px) {
    .dashboard-header {
      flex-direction: column;
      align-items: flex-start;
      padding: 1rem;
    }
    .top-meta {
      text-align: left;
      margin-top: 0.5rem;
    }
    .dashboard-title {
      font-size: 1.4rem;
    }
    h2, .section-title {
      font-size: 1.15rem;
    }
    .section {
      padding: 1rem;
    }
    .grid-container {
      gap: 1rem;
    }
    .prediction-numbers {
      flex-wrap: wrap;
    }
    .number-bubble {
      width: 50px;
      height: 50px;
      font-size: 1.8rem;
    }
    .info-block-content.color-pred, .info-block-content.size-pred {
      font-size: 2rem;
      padding: 0.8rem 1.5rem;
    }
    .button-group {
      justify-content: flex-start;
    }
    .btn {
      padding: 0.5rem 1rem;
    }
    .raw-data-controls {
      flex-direction: column;
      align-items: stretch;
    }
    #raw-json-dropdown {
      width: 100%;
    }
  }
</style>
</head>
<body>
<div class="dashboard-header-container">
  <header class="dashboard-header">
    <div class="dashboard-title">
      WinGo 1-Min Lottery Prediction Dashboard 🎲
    </div>
    <div class="top-meta">
      <div id="timestamp-display">
        <span class="label">Last Updated:</span> <span class="value" id="last-updated-time">--</span>
      </div>
      <div id="countdown-timer">Next update in: -- seconds ⏳</div>
    </div>
  </header>
</div>

<main>
  <div class="status-message error" id="error-message"></div>

  <section class="section">
    <div class="flex-row" style="align-items: center; justify-content: space-between;">
      <h2 style="margin:0; border-bottom: none;">Actions & Status 🎯</h2>
      <div class="button-group">
        <button class="btn btn-primary" onclick="manualRefresh()">Refresh 🔄</button>
        <button class="btn btn-primary" onclick="window.location.href='/api/simulator/'">Simulator 🎮</button>
        <button class="btn btn-ai" id="ai-toggle-btn" onclick="toggleAI()" aria-pressed="false" title="Enable or disable AI prediction">
          <span id="ai-toggle-btn-label">Start AI 🤖</span>
        </button>
      </div>
    </div>
    <div id="previous-draw" class="status-message info" style="margin-top: 1rem;">Loading...</div>
  </section>

  <div class="grid-container grid-2">
    <section class="section" id="ai-prediction-section">
      <h2 class="section-title">AI Predicted Number 🧠</h2>
      <div id="ai-prediction-value">--</div>
      <div id="ai-prediction-meta">
        <strong>Issue:</strong> <span id="ai-issue">--</span> | <strong>Last AI Run:</strong> <span id="ai-timestamp">--</span>
      </div>
    </section>
    <section class="section" id="ai-big-small-accuracy-section" style="background-color: #e0f2fe; border-color: #7dd3fc;">
      <h2 class="section-title">AI Big/Small Accuracy 📊</h2>
      <div id="ai-big-small-accuracy-value" style="font-size: 3rem; font-weight: 800; color: #075985;">--</div>
      <div id="ai-big-small-accuracy-meta">
          <strong>Calculated on:</strong> <span id="ai-accuracy-timestamp">--</span> |
          <strong>Correct:</strong> <span id="ai-accuracy-correct">--</span> |
          <strong>Total:</strong> <span id="ai-accuracy-total">--</span>
      </div>
    </section>
  </div>
  
  <div class="grid-container grid-2">
    <section class="section">
      <h2 class="section-title">Color Pattern Prediction 🎨</h2>
      <div class="info-block" id="color-prediction-display">
        <div class="info-block-content color-pred Pending">Pending</div>
        <div class="meta-text" id="color-prediction-meta">
            Awaiting data...
        </div>
      </div>
    </section>
    <section class="section">
      <h2 class="section-title">Size Pattern Prediction 📏</h2>
      <div class="info-block" id="size-prediction-display">
        <div class="info-block-content size-pred Pending">Pending</div>
        <div class="meta-text" id="size-prediction-meta">
            Awaiting data...
        </div>
      </div>
    </section>
  </div>

  <section class="section" id="current-prediction">
    <h2 class="section-title">Main Prediction (Draw #<span id="draw-number">--</span>) ✨</h2>
    <div class="flex-row" style="justify-content: center; gap: 2rem;">
      <div class="info-block" style="flex: 1;">
        <div class="info-block-title">Predicted Numbers</div>
        <div class="prediction-numbers" id="predicted-numbers"></div>
      </div>
      <div class="info-block" style="flex: 1;">
        <div class="info-block-title">Big/Small</div>
        <div class="info-block-content" id="predicted-big-small">--</div>
        <div class="meta-text" id="big-small-percentages"></div>
      </div>
      <div class="info-block" style="flex: 1;">
        <div class="info-block-title">Color</div>
        <div class="info-block-content" id="predicted-color">--</div>
        <div class="meta-text" id="color-percentages"></div>
      </div>
    </div>
  </section>

  <section class="section" id="sequence-analysis-section">
    <h2 class="section-title">Sequence Pattern Analysis 📈</h2>
    <div id="sequence-analysis">Loading sequence analysis...</div>
  </section>
  
  <section class="section" id="history-predictions">
    <h2 class="section-title">Main Prediction History 📜</h2>
    <div class="table-scroll">
      <table>
        <thead>
          <tr>
            <th>Draw #</th>
            <th>Prediction</th>
            <th>Actual</th>
            <th>Num</th>
            <th>B/S</th>
            <th>Color</th>
          </tr>
        </thead>
        <tbody id="history-table-body">
          <tr><td colspan="6">Loading main prediction data...</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <div class="grid-container grid-2">
    <section class="section" id="color-history-section">
      <h2 class="section-title">Color Prediction History 📜</h2>
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th>Issue #</th>
              <th>Predicted</th>
              <th>Rule</th>
              <th>Actual</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="color-history-table-body">
              <tr><td colspan="5">Loading history...</td></tr>
          </tbody>
        </table>
      </div>
    </section>
    <section class="section" id="size-history-section">
      <h2 class="section-title">Size Prediction History 📊</h2>
      <div class="table-scroll">
        <table>
          <thead>
            <tr>
              <th>Issue #</th>
              <th>Predicted</th>
              <th>Rule</th>
              <th>Actual</th>
              <th>Result</th>
            </tr>
          </thead>
          <tbody id="size-history-table-body">
              <tr><td colspan="5">Loading history...</td></tr>
          </tbody>
        </table>
      </div>
    </section>
  </div>
  
  <section class="section" id="past-performance-streaks">
    <h2 class="section-title">Main Prediction Performance & Streaks 📊📈</h2>
    <div class="performance-stats-container" id="accuracy-stats">
      <div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>
    </div>
    <div class="performance-stats-container" id="streaks-stats" style="margin-top: 1.5rem;">
      <div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>
    </div>
  </section>
  
  <div class="grid-container grid-2">
    <section class="section" id="color-performance-section">
      <h2 class="section-title">Color Prediction Performance 🚀</h2>
      <div id="color-performance-stats">
          <p>Loading performance data...</p>
      </div>
    </section>
    <section class="section" id="size-performance-section">
      <h2 class="section-title">Size Prediction Performance 📊</h2>
      <div id="size-performance-stats">
          <p>Loading performance data...</p>
      </div>
    </section>
  </div>
  
  <section class="section" id="raw-json-section">
    <div class="raw-data-controls">
      <h2 style="margin:0; border-bottom: none;">Raw API Responses</h2>
      <select id="raw-json-dropdown" onchange="updateRawJsonDisplay()">
        <option value="prediction">Main Prediction</option>
        <option value="color_insights">Color Insights</option>
        <option value="size_insights">Size Insights</option>
        <option value="v2_insights">Combined Insights</option>
        <option value="ai_prediction">AI Prediction</option>
        <option value="ai_big_small_accuracy">AI B/S Accuracy</option>
        <option value="status">Status</option>
      </select>
    </div>
    <pre id="raw-json-display" class="raw-json-display">
      <button id="copy-json-btn">Copy</button>No data loaded yet.
    </pre>
  </section>
</main>

<script>
  const NUM_TO_COLOR_MAP = {
    0: 'Red', 1: 'Green', 2: 'Red', 3: 'Green', 4: 'Red',
    5: 'Green', 6: 'Red', 7: 'Green', 8: 'Red', 9: 'Green'
  };
  const COLOR_MAP = {
    0: {primary: 'Red', secondary: 'Violet'}, 1: {primary: 'Green', secondary: null},
    2: {primary: 'Red', secondary: null}, 3: {primary: 'Green', secondary: null},
    4: {primary: 'Red', secondary: null}, 5: {primary: 'Green', secondary: 'Violet'},
    6: {primary: 'Red', secondary: null}, 7: {primary: 'Green', secondary: null},
    8: {primary: 'Red', secondary: null}, 9: {primary: 'Green', secondary: null}
  };

  function createChip(text, color) {
    const safeText = text ? String(text) : '';
    const safeColor = color ? String(color).toLowerCase() : 'gray';
    const validColors = ['red', 'green', 'violet', 'gray', 'blue', 'gold'];
    const finalColor = validColors.includes(safeColor) ? safeColor : 'gray';
    return `<span class="chip ${finalColor}">${safeText}</span>`;
  }
  
  function createHistoryChip(text, type) {
    const safeText = text ? String(text) : 'Pending';
    let safeType = safeText === 'Pending' ? 'Pending' : safeText;
    if (!type.startsWith('Result-')) {
        safeType = 'Result-' + safeType;
    } else {
        safeType = type;
    }
    return `<span class="chip ${safeType}">${safeText}</span>`;
  }

  function formatTimestamp(isoString) {
    try {
      if (!isoString) return '--';
      const date = new Date(isoString);
      if (isNaN(date.getTime())) throw new Error("Invalid date string");
      return date.toLocaleString('en-US', {
        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
      });
    } catch (e) {
      console.error("Error formatting timestamp:", e);
      return '-- Invalid --';
    }
  }

  let timerIntervalId = null;
  let countdownSeconds = 60;
  let lastApiTimestamp = null;
  
  const refreshTimes = [1.5, 5.0, 10.0, 58.5];

  let refreshGate = {
    '1.5': false,
    '5.0': false,
    '10.0': false,
    '58.5': false,
  };
  
  function checkRefreshTime() {
    const now = new Date();
    const currentSecond = now.getSeconds();
    const currentMs = now.getMilliseconds();
    
    if (currentSecond === 58 && currentMs >= 500 && !refreshGate['58.5']) {
      loadAllData();
      refreshGate['58.5'] = true;
    }
    if (currentSecond === 1 && currentMs >= 500 && !refreshGate['1.5']) {
      loadAllData();
      refreshGate['1.5'] = true;
    }
    if (currentSecond === 5 && currentMs >= 0 && currentMs <= 100 && !refreshGate['5.0']) {
      loadAllData();
      refreshGate['5.0'] = true;
    }
    if (currentSecond === 10 && currentMs >= 0 && currentMs <= 100 && !refreshGate['10.0']) {
      loadAllData();
      refreshGate['10.0'] = true;
    }
    
    if (currentMs < 100) {
      if (currentSecond !== 58 && refreshGate['58.5']) refreshGate['58.5'] = false;
      if (currentSecond !== 1 && refreshGate['1.5']) refreshGate['1.5'] = false;
      if (currentSecond !== 5 && refreshGate['5.0']) refreshGate['5.0'] = false;
      if (currentSecond !== 10 && refreshGate['10.0']) refreshGate['10.0'] = false;
    }
  }

  function updateCountdownDisplay() {
    if (!lastApiTimestamp) {
      document.getElementById('countdown-timer').textContent = "Next update in: -- seconds (No timestamp)";
      return;
    }
    const now = new Date();
    const apiDate = new Date(lastApiTimestamp);
    let elapsedSeconds = Math.floor((now.getTime() - apiDate.getTime()) / 1000);
    if (elapsedSeconds < 0) elapsedSeconds = 0;
    
    let remaining = countdownSeconds - (elapsedSeconds % countdownSeconds);
    if (remaining <= 1 && elapsedSeconds > 0) {
      remaining = countdownSeconds;
    }
    document.getElementById('countdown-timer').textContent = `Next update in: ${remaining}s ⏳`;
  }

  function manualRefresh() {
    document.getElementById('countdown-timer').textContent = `Refreshing...`;
    loadAllData();
  }
  
  let rawApiResponses = { 
    prediction: null, 
    ai_prediction: null, 
    status: null, 
    ai_big_small_accuracy: null, 
    color_insights: null,
    size_insights: null,
    v2_insights: null
  };

  function updateRawJsonDisplay() {
    const dropdown = document.getElementById('raw-json-dropdown');
    const display = document.getElementById('raw-json-display');
    const selected = dropdown.value;
    const content = rawApiResponses[selected] ? JSON.stringify(rawApiResponses[selected], null, 2) : `No data for ${selected}.`;
    
    if (!display.querySelector('#copy-json-btn')) {
        display.innerHTML = `<button id="copy-json-btn">Copy</button>${content}`;
    } else {
        display.firstChild.nextSibling.textContent = content;
    }

    const copyBtn = document.getElementById('copy-json-btn');
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(content)
            .then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.textContent = originalText, 1500);
            })
            .catch(err => console.error('Failed to copy text: ', err));
    };
  }

  let aiEnabled = false;

  async function fetchAIStatusAndUpdateBtn() {
    try {
      const res = await fetch('/api/ai/status');
      if (!res.ok) throw new Error('Failed to fetch AI status');
      const data = await res.json();
      aiEnabled = !!data.ai_enabled_flag;
    } catch (e) {
      aiEnabled = false;
      console.error("Error fetching AI status:", e);
      showErrorMessage("Failed to fetch AI status.");
    } finally {
      updateAIToggleBtn();
    }
  }

  function updateAIToggleBtn() {
    const btn = document.getElementById('ai-toggle-btn');
    const label = document.getElementById('ai-toggle-btn-label');
    const aiPredValue = document.getElementById('ai-prediction-value');
    
    if (!btn || !label || !aiPredValue) return;
    
    if (aiEnabled) {
      btn.classList.add('active');
      label.textContent = 'Stop AI 🛑';
    } else {
      btn.classList.remove('active');
      label.textContent = 'Start AI 🤖';
      aiPredValue.innerHTML = `<span style="font-size: 1rem; color: #6b7280;">AI is OFF</span>`;
    }
  }

  async function toggleAI() {
    const endpoint = aiEnabled ? '/api/ai/stop' : '/api/ai/start';
    document.getElementById('ai-toggle-btn').disabled = true;
    try {
      const res = await fetch(endpoint, { method: 'POST' });
      if (!res.ok) throw new Error((await res.json()).message || 'Unknown error');
      const data = await res.json();
      aiEnabled = !!data.ai_enabled_flag;
      updateAIToggleBtn();
      loadAIPredictionData();
      loadAIBigSmallAccuracy();
    } catch (e) {
      showErrorMessage('Failed to toggle AI: ' + e.message);
    } finally {
      document.getElementById('ai-toggle-btn').disabled = false;
    }
  }

  function showErrorMessage(message) {
      const errorDiv = document.getElementById('error-message');
      errorDiv.textContent = message;
      errorDiv.style.display = "block";
      setTimeout(() => errorDiv.style.display = "none", 5000);
  }

  // --- Main Prediction Data Loading ---
  async function loadMainPredictionData() {
    try {
        const res = await fetch('/api/prediction');
        const data = await res.json();
        rawApiResponses['prediction'] = data;

        if (data.timestamp) {
            lastApiTimestamp = data.timestamp;
        }

        const prevDrawElem = document.getElementById('previous-draw');
        if (data.status === 'initializing') {
            prevDrawElem.className = 'status-message info';
            prevDrawElem.innerHTML = `⏳ Main prediction system initializing...`;
        } else if (data.status === 'error') {
            prevDrawElem.className = 'status-message error';
            prevDrawElem.innerHTML = `❌ Error: ${data.message}`;
        } else {
            const drawNumber = data.next_issue || data.issue || '--';
            const prediction = data.prediction || {};
            const predictedNumbers = prediction.predicted_likelihoods || [];
            const bigSmall = prediction.big_small || '--';
            const color = prediction.color || '--';

            document.getElementById('draw-number').textContent = String(drawNumber).slice(-4);
            
            const numbersContainer = document.getElementById('predicted-numbers');
            if (predictedNumbers && predictedNumbers.length > 0) {
                numbersContainer.innerHTML = '';
                [...predictedNumbers].sort((a, b) => b.likelihood - a.likelihood).forEach(item => {
                    const bubble = document.createElement('div');
                    bubble.className = 'number-bubble';
                    bubble.textContent = item.number;
                    if ([0, 2, 4, 6, 8].includes(item.number)) bubble.classList.add('red');
                    if ([1, 3, 5, 7, 9].includes(item.number)) bubble.classList.add('green');
                    if ([0, 5].includes(item.number)) bubble.classList.add('violet');
                    const pctDiv = document.createElement('div');
                    pctDiv.className = 'bubble-pct';
                    pctDiv.textContent = `${item.likelihood.toFixed(1)}%`;
                    bubble.appendChild(pctDiv);
                    numbersContainer.appendChild(bubble);
                });
            } else {
                numbersContainer.innerHTML = '<div class="number-bubble" style="background: #999;">--</div>';
            }

            document.getElementById('predicted-big-small').textContent = bigSmall;
            const bigSmallPercentages = document.getElementById('big-small-percentages');
            if (prediction.big_small_percentages) {
                bigSmallPercentages.innerHTML = Object.entries(prediction.big_small_percentages)
                    .map(([k, v]) => `<span>${k.replace('_percentage', '')}: ${v.toFixed(1)}%</span>`).join(' | ');
            }

            document.getElementById('predicted-color').textContent = color;
            const colorPercentages = document.getElementById('color-percentages');
            if (prediction.color_percentages) {
                colorPercentages.innerHTML = Object.entries(prediction.color_percentages)
                    .map(([k, v]) => `<span>${k}: ${v.toFixed(1)}%</span>`).join(' | ');
            }

            if (data.recent_results) {
                const recentIssues = Object.keys(data.recent_results).sort((a,b) => b.localeCompare(a));
                if (recentIssues.length > 0) {
                    const lastIssueKey = recentIssues[0];
                    const lastNum = data.recent_results[lastIssueKey];
                    const lastColor = NUM_TO_COLOR_MAP[lastNum] || '--';
                    const lastSize = lastNum >= 5 ? 'Big' : 'Small';
                    prevDrawElem.className = 'status-message success';
                    prevDrawElem.innerHTML = `Previous Draw #${String(lastIssueKey).slice(-4)}: <strong>${lastNum}</strong> (${lastColor}, ${lastSize})`;
                }
            } else {
                prevDrawElem.className = 'status-message info';
                prevDrawElem.innerHTML = `Current Prediction for Draw #${String(drawNumber).slice(-4)}`;
            }

            const seqDiv = document.getElementById('sequence-analysis');
            if (data.sequence_analysis && data.sequence_analysis.length > 0) {
                seqDiv.innerHTML = data.sequence_analysis.map(item => `
                    <div style="margin-bottom:0.7em;">
                        <p style="margin:0;"><b>Pattern [${item.pattern.join(', ')}]:</b> ${item.predictions.map(p => `<strong>${p.number}</strong>`).join(', ')}</p>
                        <p style="color:#888;font-size:0.9em;margin:0.2em 0 0;"><em>${item.message}</em></p>
                    </div>
                `).join('');
            } else { 
                seqDiv.innerHTML = '<p>No significant patterns detected.</p>'; 
            }

            updateMainPredictionHistory(data.prediction_history || []);
            updateMainPerformanceStats(data.accuracy, data.streaks);
        }

    } catch (err) {
        console.error("Failed to load main prediction data:", err);
        showErrorMessage(`Failed to load main prediction: ${err.message}`);
        document.getElementById('previous-draw').innerHTML = `<span style="color: #d32f2f;">❌ Failed to load main prediction data</span>`;
    }
  }

  function updateMainPredictionHistory(historyData) {
    const tbody = document.getElementById('history-table-body');
    if (!historyData || historyData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6">No main prediction history available.</td></tr>';
        return;
    }

    tbody.innerHTML = '';
    historyData.slice(0, 15).forEach(item => {
        const tr = document.createElement('tr');
        const pred = item.prediction || {};
        const res = item.result || {};
        const corr = item.correct || {};

        const predText = `<b>${pred.number ? pred.number.join('/') : '--'}</b><br>${pred.big_small || '--'}<br>${createHistoryChip(pred.color, `Result-${pred.color}`)}`;
        
        const actualNum = res.number !== undefined ? res.number : '--';
        const actualColors = (res.colors || []).filter(Boolean).map(c => createHistoryChip(c, `Result-${c}`)).join(' ');
        const actualBS = res.big_small || '--';
        
        const actualText = `<b>${actualNum}</b><br>${actualBS}<br>${actualColors}`;

        tr.innerHTML = `
            <td>${String(item.issue).slice(-4)}</td>
            <td>${predText}</td>
            <td>${actualText}</td>
            <td class="${corr.number ? 'correct' : 'incorrect'}">${corr.number ? '✔' : '✘'}</td>
            <td class="${corr.big_small ? 'correct' : 'incorrect'}">${corr.big_small ? '✔' : '✘'}</td>
            <td class="${corr.color ? 'correct' : 'incorrect'}">${corr.color ? '✔' : '✘'}</td>
        `;
        tbody.appendChild(tr);
    });
  }

  function updateMainPerformanceStats(accuracyStats, streakStats) {
    const accuracyContainer = document.getElementById('accuracy-stats');
    const streaksContainer = document.getElementById('streaks-stats');

    if (accuracyStats) {
        const parsePercent = (str) => (str || "0%").match(/(\d+\.?\d*)/)?.[0] || "0";
        accuracyContainer.innerHTML = `
            <div class="stat-card">
                <div class="stat-label">Numbers Acc.</div>
                <div class="stat-value">${parsePercent(accuracyStats.number_accuracy)}%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Color Acc.</div>
                <div class="stat-value">${parsePercent(accuracyStats.color_accuracy)}%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Big/Small Acc.</div>
                <div class="stat-value">${parsePercent(accuracyStats.big_small_accuracy)}%</div>
            </div>
        `;
    } else {
        accuracyContainer.innerHTML = '<div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>';
    }

    if (streakStats) {
        streaksContainer.innerHTML = '';
        Object.entries(streakStats).forEach(([key, val]) => {
            const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            streaksContainer.innerHTML += `
                <div class="stat-card">
                    <div class="stat-label">${label} Streaks</div>
                    <div class="streak-row">Win: <strong class="win-streak-value">${val.current_win || 0}</strong> (Max: ${val.max_win || 0})</div>
                    <div class="streak-row">Loss: <strong class="loss-streak-value">${val.current_loss || 0}</strong> (Max: ${val.max_loss || 0})</div>
                </div>
            `;
        });
    } else {
        streaksContainer.innerHTML = '<div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>';
    }
  }

  // --- Color Insights Data Loading ---
  async function loadColorInsightsData() {
    const predDisplay = document.getElementById('color-prediction-display');
    const perfStats = document.getElementById('color-performance-stats');
    const historyBody = document.getElementById('color-history-table-body');

    try {
        const res = await fetch('/api/color_insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['color_insights'] = data;

        const pred = data.color_prediction;
        if (pred && pred.next_color) {
            predDisplay.innerHTML = `
                <div class="info-block-content color-pred ${pred.next_color}">${pred.next_color}</div>
                <div class="meta-text" id="color-prediction-meta">
                    For Issue #<strong>${String(pred.issue).slice(-4)}</strong> based on <strong>${pred.rule_name || 'N/A'}</strong> (Score: ${pred.rule_score || 0}%)
                    <br>Observed Sequence: <span id="color-pred-sequence" style="font-family:'Roboto Mono',monospace; background: #eef4ff; padding: 2px 6px; border-radius: 4px; letter-spacing: 2px;">${pred.observed_sequence || 'N/A'}</span>
                    <br>Last Updated: ${formatTimestamp(pred.last_updated)}
                </div>
            `;
        } else {
            predDisplay.innerHTML = `<div class="info-block-content color-pred Pending">Pending</div><div class="meta-text" id="color-prediction-meta">No active color prediction.</div>`;
        }

        const acc = data.color_accuracy;
        const streaks = data.color_streaks;
        if (acc && streaks) {
            let perRuleHtml = '<p>No rule data.</p>';
            if (acc.per_rule && Object.keys(acc.per_rule).length > 0) {
              perRuleHtml = `
                <table style="font-size:0.8rem;">
                  <thead><tr><th>Rule</th><th>Accuracy</th><th>Count</th></tr></thead>
                  <tbody>
                    ${Object.entries(acc.per_rule).sort(([,a],[,b]) => b.total - a.total).map(([rule, stats]) => `
                      <tr>
                        <td>${rule}</td>
                        <td>${stats.accuracy_pct.toFixed(1)}%</td>
                        <td>${stats.correct}/${stats.total}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>`;
            }
            
            let winDistributionHtml = '';
            if (streaks.win_streak_distribution && Object.keys(streaks.win_streak_distribution).length > 0) {
                winDistributionHtml = `
                    <h3>Win Streak Count</h3>
                    <div class="table-scroll">
                      <table style="font-size:0.8rem;">
                          <thead><tr><th>Length</th><th>Count</th></tr></thead>
                          <tbody>
                              ${Object.entries(streaks.win_streak_distribution).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([length, count]) => `
                                  <tr><td>${length}</td><td>${count}</td></tr>
                              `).join('')}
                          </tbody>
                      </table>
                    </div>
                `;
            }
            
            let loseDistributionHtml = '';
            if (streaks.lose_streak_distribution && Object.keys(streaks.lose_streak_distribution).length > 0) {
                loseDistributionHtml = `
                    <h3>Loss Streak Count</h3>
                    <div class="table-scroll">
                      <table style="font-size:0.8rem;">
                          <thead><tr><th>Length</th><th>Count</th></tr></thead>
                          <tbody>
                              ${Object.entries(streaks.lose_streak_distribution).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([length, count]) => `
                                  <tr><td>${length}</td><td>${count}</td></tr>
                              `).join('')}
                          </tbody>
                      </table>
                    </div>
                `;
            }

            perfStats.innerHTML = `
                <div class="performance-stats-container">
                    <div class="stat-card"><div class="stat-label">Accuracy</div><div class="stat-value">${(acc.accuracy_percentage || 0).toFixed(2)}%</div></div>
                    <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value">${acc.correct_predictions || 0}/${acc.total_predictions || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Current Win</div><div class="stat-value win-streak-value">${streaks.current_win_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Current Loss</div><div class="stat-value loss-streak-value">${streaks.current_lose_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Max Win</div><div class="stat-value">${streaks.max_win_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Max Loss</div><div class="stat-value">${streaks.max_lose_streak || 0}</div></div>
                </div>
                <div style="margin-top: 1.5rem;">
                  <h3 class="section-title" style="font-size:1.1rem; margin-bottom:0.5rem; border:none;">Accuracy by Rule</h3>
                  ${perRuleHtml}
                </div>
                <div class="grid-container grid-2" style="margin-top: 1.5rem; margin-bottom: 0;">
                    <div>${winDistributionHtml || ''}</div>
                    <div>${loseDistributionHtml || ''}</div>
                </div>
            `;
        } else {
            perfStats.innerHTML = '<p>No color performance data available.</p>';
        }

        const historyData = data.color_prediction_history;
        historyBody.innerHTML = '';
        if (historyData && historyData.length > 0) {
            historyData.forEach(item => {
                const actualColor = item.actual_color;
                const isCorrect = actualColor !== null && item.predicted_color === actualColor;

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${String(item.issue).slice(-4)}</td>
                    <td>${createHistoryChip(item.predicted_color, 'Result-'+item.predicted_color)}</td>
                    <td>${item.rule_name || 'N/A'}</td>
                    <td>${createHistoryChip(actualColor, 'Result-'+actualColor)}</td>
                    <td class="${actualColor ? (isCorrect ? 'correct' : 'incorrect') : ''}">
                        ${actualColor ? (isCorrect ? '✔' : '✘') : '?'}
                    </td>
                `;
                historyBody.appendChild(tr);
            });
        } else {
            historyBody.innerHTML = '<tr><td colspan="5">No color prediction history available.</td></tr>';
        }

    } catch (err) {
        console.error("Failed to load color insights:", err);
        showErrorMessage(`Failed to load Color Insights: ${err.message}`);
        predDisplay.innerHTML = `<div class="info-block-content color-pred Pending">Error</div><div class="meta-text" id="color-prediction-meta">Could not fetch color data.</div>`;
        perfStats.innerHTML = '<p>Error loading performance data.</p>';
        historyBody.innerHTML = '<tr><td colspan="5">Error loading history.</td></tr>';
    }
  }

  // --- Size Insights Data Loading ---
  async function loadSizeInsightsData() {
    const predDisplay = document.getElementById('size-prediction-display');
    const perfStats = document.getElementById('size-performance-stats');
    const historyBody = document.getElementById('size-history-table-body');

    try {
        const res = await fetch('/api/size_insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['size_insights'] = data;

        const pred = data.size_prediction;
        if (pred && pred.next_size) {
            predDisplay.innerHTML = `
                <div class="info-block-content size-pred ${pred.next_size}">${pred.next_size}</div>
                <div class="meta-text" id="size-prediction-meta">
                    For Issue #<strong>${String(pred.issue).slice(-4)}</strong> based on <strong>${pred.rule_name || 'N/A'}</strong> (Score: ${pred.rule_score || 0}%)
                    <br>Observed Sequence: <span id="size-pred-sequence" style="font-family:'Roboto Mono',monospace; background: #eef4ff; padding: 2px 6px; border-radius: 4px; letter-spacing: 2px;">${pred.observed_sequence || 'N/A'}</span>
                    <br>Last Updated: ${formatTimestamp(pred.last_updated)}
                </div>
            `;
        } else {
            predDisplay.innerHTML = `<div class="info-block-content size-pred Pending">Pending</div><div class="meta-text" id="size-prediction-meta">No active size prediction.</div>`;
        }

        const acc = data.size_accuracy;
        const streaks = data.size_streaks;
        if (acc && streaks) {
            let perRuleHtml = '<p>No rule data.</p>';
            if (acc.per_rule && Object.keys(acc.per_rule).length > 0) {
              perRuleHtml = `
                <table style="font-size:0.8rem;">
                  <thead><tr><th>Rule</th><th>Accuracy</th><th>Count</th></tr></thead>
                  <tbody>
                    ${Object.entries(acc.per_rule).sort(([,a],[,b]) => b.total - a.total).map(([rule, stats]) => `
                      <tr>
                        <td>${rule}</td>
                        <td>${stats.accuracy_pct.toFixed(1)}%</td>
                        <td>${stats.correct}/${stats.total}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>`;
            }
            
            let winDistributionHtml = '';
            if (streaks.win_streak_distribution && Object.keys(streaks.win_streak_distribution).length > 0) {
                winDistributionHtml = `
                    <h3>Win Streak Count</h3>
                    <div class="table-scroll">
                      <table style="font-size:0.8rem;">
                          <thead><tr><th>Length</th><th>Count</th></tr></thead>
                          <tbody>
                              ${Object.entries(streaks.win_streak_distribution).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([length, count]) => `
                                  <tr><td>${length}</td><td>${count}</td></tr>
                              `).join('')}
                          </tbody>
                      </table>
                    </div>
                `;
            }
            
            let loseDistributionHtml = '';
            if (streaks.lose_streak_distribution && Object.keys(streaks.lose_streak_distribution).length > 0) {
                loseDistributionHtml = `
                    <h3>Loss Streak Count</h3>
                    <div class="table-scroll">
                      <table style="font-size:0.8rem;">
                          <thead><tr><th>Length</th><th>Count</th></tr></thead>
                          <tbody>
                              ${Object.entries(streaks.lose_streak_distribution).sort((a, b) => parseInt(a[0]) - parseInt(b[0])).map(([length, count]) => `
                                  <tr><td>${length}</td><td>${count}</td></tr>
                              `).join('')}
                          </tbody>
                      </table>
                    </div>
                `;
            }

            perfStats.innerHTML = `
                <div class="performance-stats-container">
                    <div class="stat-card"><div class="stat-label">Accuracy</div><div class="stat-value">${(acc.accuracy_percentage || 0).toFixed(2)}%</div></div>
                    <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value">${acc.correct_predictions || 0}/${acc.total_predictions || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Current Win</div><div class="stat-value win-streak-value">${streaks.current_win_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Current Loss</div><div class="stat-value loss-streak-value">${streaks.current_lose_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Max Win</div><div class="stat-value">${streaks.max_win_streak || 0}</div></div>
                    <div class="stat-card"><div class="stat-label">Max Loss</div><div class="stat-value">${streaks.max_lose_streak || 0}</div></div>
                </div>
                <div style="margin-top: 1.5rem;">
                  <h3 class="section-title" style="font-size:1.1rem; margin-bottom:0.5rem; border:none;">Accuracy by Rule</h3>
                  ${perRuleHtml}
                </div>
                <div class="grid-container grid-2" style="margin-top: 1.5rem; margin-bottom: 0;">
                    <div>${winDistributionHtml || ''}</div>
                    <div>${loseDistributionHtml || ''}</div>
                </div>
            `;
        } else {
            perfStats.innerHTML = '<p>No size performance data available.</p>';
        }

        const historyData = data.size_prediction_history;
        historyBody.innerHTML = '';
        if (historyData && historyData.length > 0) {
            historyData.forEach(item => {
                const actualSize = item.actual_size;
                const isCorrect = actualSize !== null && item.predicted_size === actualSize;
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${String(item.issue).slice(-4)}</td>
                    <td>${createHistoryChip(item.predicted_size, 'Result-'+item.predicted_size)}</td>
                    <td>${item.rule_name || 'N/A'}</td>
                    <td>${createHistoryChip(actualSize, 'Result-'+actualSize)}</td>
                    <td class="${actualSize ? (isCorrect ? 'correct' : 'incorrect') : ''}">
                        ${actualSize ? (isCorrect ? '✔' : '✘') : '?'}
                    </td>
                `;
                historyBody.appendChild(tr);
            });
        } else {
            historyBody.innerHTML = '<tr><td colspan="5">No size prediction history available.</td></tr>';
        }

    } catch (err) {
        console.error("Failed to load size insights:", err);
        showErrorMessage(`Failed to load Size Insights: ${err.message}`);
        predDisplay.innerHTML = `<div class="info-block-content size-pred Pending">Error</div><div class="meta-text" id="size-prediction-meta">Could not fetch size data.</div>`;
        perfStats.innerHTML = '<p>Error loading performance data.</p>';
        historyBody.innerHTML = '<tr><td colspan="5">Error loading history.</td></tr>';
    }
  }

  async function loadAIPredictionData() {
    const valElem = document.getElementById('ai-prediction-value');
    const issueElem = document.getElementById('ai-issue');
    const tsElem = document.getElementById('ai-timestamp');

    valElem.textContent = '--'; issueElem.textContent = '--'; tsElem.textContent = '--';
    valElem.classList.remove('red', 'green', 'violet');

    if (!aiEnabled) {
      valElem.innerHTML = `<span style="font-size: 1rem; color: #6b7280;">AI is OFF</span>`;
      return;
    }

    try {
        const res = await fetch('/api/ai_prediction');
        const data = await res.json();
        rawApiResponses['ai_prediction'] = data;
        
        if (data.status === 'no_data' || data.ai_prediction === undefined) {
            valElem.innerHTML = `<span style="font-size: 1rem; color: #6b7280;">No Data</span>`;
        } else {
            const predNum = parseInt(data.ai_prediction);
            valElem.textContent = predNum;
            issueElem.textContent = String(data.issue).slice(-4);
            tsElem.textContent = formatTimestamp(data.timestamp);
            if (!isNaN(predNum)) {
                if ([0, 2, 4, 6, 8].includes(predNum)) valElem.classList.add('red');
                if ([1, 3, 5, 7, 9].includes(predNum)) valElem.classList.add('green');
                if ([0, 5].includes(predNum)) valElem.classList.add('violet');
            }
        }
    } catch (err) {
        showErrorMessage(`Failed to load AI data: ${err.message}`);
        valElem.innerHTML = `<span style="font-size: 1rem; color: #6b7280;">Error</span>`;
    }
  }

  async function loadAIBigSmallAccuracy() {
    const valElem = document.getElementById('ai-big-small-accuracy-value');
    const tsElem = document.getElementById('ai-accuracy-timestamp');
    const correctElem = document.getElementById('ai-accuracy-correct');
    const totalElem = document.getElementById('ai-accuracy-total');

    valElem.textContent = '--'; tsElem.textContent = '--'; correctElem.textContent = '--'; totalElem.textContent = '--';
    if (!aiEnabled) return;

    try {
        const res = await fetch('/api/ai_big_small_accuracy');
        const data = await res.json();
        rawApiResponses['ai_big_small_accuracy'] = data;
        if (data.status === 'success' && data.accuracy !== undefined) {
            valElem.textContent = `${data.accuracy.toFixed(2)}%`;
            correctElem.textContent = data.correct_predictions;
            totalElem.textContent = data.total_predictions;
            tsElem.textContent = formatTimestamp(data.timestamp);
        } else {
            valElem.textContent = 'N/A';
        }
    } catch (err) {
        showErrorMessage(`Failed to load AI B/S accuracy: ${err.message}`);
        valElem.textContent = 'Error';
    }
  }

  async function loadCombinedInsightsData() {
    try {
        const res = await fetch('/api/v2/insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['v2_insights'] = data;
    } catch (err) {
        console.error("Failed to load combined insights:", err);
    }
  }

  // Main data loading function
  async function loadAllData() {
    try {
        document.getElementById('last-updated-time').textContent = formatTimestamp(new Date().toISOString());
        
        await Promise.all([
            loadMainPredictionData(),           
            loadColorInsightsData(),
            loadSizeInsightsData(),
            loadCombinedInsightsData(),
            fetchAIStatusAndUpdateBtn().then(() => {
                return Promise.all([
                    loadAIPredictionData(),
                    loadAIBigSmallAccuracy()
                ]);
            })
        ]);
        
        updateRawJsonDisplay();
        
    } catch (err) {
        console.error("Error loading data:", err);
        showErrorMessage(`Error loading dashboard data: ${err.message}`);
    }
  }

  // Initialize and start timers
  function init() {
    loadAllData();
    
    timerIntervalId = setInterval(() => {
        checkRefreshTime();
    }, 100);

    setInterval(updateCountdownDisplay, 1000);
  }

  window.onload = init;
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Wingo 1 min Lottery Prediction Dashboard</title>
<style>
  /* --- Google Fonts for a modern look --- */
  @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Fira+Code&display=swap');

  /* --- CSS Variables for easy theme management --- */
  :root {
    --bg-main: #f0f2f5;
    --bg-card: #ffffff;
    --primary-text: #1f2937;
    --secondary-text: #6b7280;
    --border-color: #e5e7eb;
    --header-bg: #111827;
    --header-text: #f9fafb;
    --accent-color: #3b82f6;
    --accent-hover: #2563eb;
    --green-color: #10b981;
    --red-color: #ef4444;
    --violet-color: #8b5cf6;
    --orange-color: #f97316;
    --blue-color: #3b82f6;
    --gold-color: #f59e0b;
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --border-radius: 0.75rem; /* 12px */
  }

  /* --- Reset & Base Styles --- */
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  body {
    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background-color: var(--bg-main);
    color: var(--primary-text);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    line-height: 1.6;
  }

  /* --- Sticky Header --- */
  header {
    background: var(--header-bg);
    color: var(--header-text);
    padding: 0.75rem 1.5rem;
    box-shadow: var(--shadow-md);
    position: sticky;
    top: 0;
    z-index: 1000;
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
  }

  .header-title {
    font-weight: 700;
    font-size: 1.5rem;
    letter-spacing: 0.5px;
  }
  
  .header-info {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.25rem;
    text-align: right;
  }
  
  #timestamp-display {
    font-size: 0.8rem;
    color: #d1d5db;
  }
  
  #countdown-timer {
    font-weight: 500;
    font-size: 1rem;
    color: var(--header-text);
    background-color: rgba(255, 255, 255, 0.1);
    padding: 0.25rem 0.75rem;
    border-radius: 999px;
  }


  /* --- Main Content Area --- */
  main {
    flex: 1;
    padding: 1.5rem;
    max-width: 1200px;
    margin: 0 auto;
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* --- Card/Section Styling --- */
  .section {
    background: var(--bg-card);
    border-radius: var(--border-radius);
    padding: 1.5rem;
    box-shadow: var(--shadow-md);
    border: 1px solid var(--border-color);
  }

  h2 {
    font-size: 1.25rem;
    font-weight: 700;
    color: var(--primary-text);
    margin-bottom: 1.25rem;
    padding-bottom: 0.75rem;
    border-bottom: 2px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  /* --- Layout Helpers --- */
  .grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
  }

  /* --- Prediction Bubbles --- */
  .prediction-numbers {
    display: flex;
    gap: 0.8rem;
    margin-top: 0.5rem;
    justify-content: center;
    flex-wrap: wrap;
  }

  .number-bubble {
    background-color: var(--secondary-text);
    color: white;
    font-weight: 700;
    font-size: 2.25rem;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    box-shadow: var(--shadow-sm);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border: 2px solid transparent;
  }
  .number-bubble:hover {
    transform: translateY(-3px);
  }
  .bubble-pct {
    font-size: 0.75rem;
    font-weight: 500;
    margin-top: 2px;
  }

  /* --- Prediction Details --- */
  .main-prediction-details {
    display: flex;
    justify-content: space-around;
    align-items: center;
    gap: 1.5rem;
    margin-top: 1rem;
    flex-wrap: wrap;
  }
  .prediction-detail-group {
    text-align: center;
    flex-grow: 1;
  }
  .prediction-detail {
    font-weight: 500;
    font-size: 1.1rem;
    color: var(--secondary-text);
  }
  .prediction-value {
    font-weight: 700;
    font-size: 1.75rem;
    color: var(--primary-text);
  }
  .percentages {
    font-size: 0.875rem;
    color: var(--secondary-text);
    margin-top: 0.25rem;
  }
  .percentages span {
    margin: 0 0.5rem;
  }

  /* --- Previous Draw & Sequence --- */
  #previous-draw-section {
    text-align: center;
    padding: 1rem;
  }
  .previous-draw {
    font-weight: 500;
    font-size: 1.25rem;
    color: var(--primary-text);
  }
  .previous-draw strong {
    font-size: 1.5rem;
    color: var(--accent-color);
  }

  /* --- Color & Size Pattern Prediction Cards --- */
  .pattern-prediction-box {
    text-align: center;
  }
  .pattern-pred-value {
    font-size: 3rem;
    font-weight: 700;
    color: white;
    padding: 1.5rem 2.5rem;
    border-radius: var(--border-radius);
    display: inline-block;
    min-width: 200px;
    margin: 0.5rem auto;
    box-shadow: var(--shadow-md);
    text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
  }
  .pattern-pred-value.Red { background-color: var(--red-color); }
  .pattern-pred-value.Green { background-color: var(--green-color); }
  .pattern-pred-value.Big { background-color: var(--orange-color); }
  .pattern-pred-value.Small { background-color: var(--blue-color); }
  .pattern-pred-value.Pending { background-color: var(--secondary-text); }
  
  .pattern-pred-meta {
    font-size: 0.875rem;
    color: var(--secondary-text);
    margin-top: 1rem;
    line-height: 1.5;
  }
  .pattern-pred-meta strong { color: var(--primary-text); }
  .pred-sequence-code {
    font-family: 'Fira Code', monospace;
    font-size: 1em;
    background: var(--bg-main);
    padding: 0.25rem 0.5rem;
    border-radius: 6px;
    letter-spacing: 1px;
    border: 1px solid var(--border-color);
  }
  
  /* --- AI Prediction Section --- */
  #ai-prediction-section h2, #ai-big-small-accuracy-section h2 {
    border-bottom-color: var(--accent-color);
  }
  #ai-prediction-value {
    font-size: 4rem;
    font-weight: 700;
    color: var(--accent-color);
    margin-bottom: 0.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5rem;
  }
  #ai-prediction-meta, #ai-big-small-accuracy-meta {
    font-size: 0.875rem;
    color: var(--secondary-text);
  }
  #ai-big-small-accuracy-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--green-color);
  }

  .ai-toggle-btn {
    background-color: #fffde7;
    color: var(--accent-color);
    border: 2px solid var(--gold-color);
    border-radius: 50px;
    padding: 0.5rem 1.25rem;
    font-size: 0.9rem;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    box-shadow: var(--shadow-sm);
  }
  .ai-toggle-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }
  .ai-toggle-btn.active {
    background-color: var(--gold-color);
    color: var(--header-bg);
    border-color: var(--accent-color);
  }
  .ai-badge {
    display: inline-block;
    background: var(--gold-color);
    color: var(--header-bg);
    border-radius: 12px;
    font-size: 1rem;
    font-weight: 700;
    padding: 0.25rem 0.8rem;
    margin-left: 0.5rem;
    vertical-align: middle;
    letter-spacing: 0.5px;
  }
  .ai-badge[disabled] { background: #e5e7eb; color: #9ca3af; }


  /* --- History Tables --- */
  .table-container {
    overflow-x: auto;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
  }
  thead {
    background: #f3f4f6;
  }
  th, td {
    padding: 0.75rem;
    text-align: center;
    border-bottom: 1px solid var(--border-color);
    vertical-align: middle;
  }
  th {
    font-weight: 500;
    color: var(--secondary-text);
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
  }
  tbody tr:last-child td { border-bottom: none; }
  tbody tr:hover { background: #fafafa; }
  
  .correct { color: var(--green-color); font-weight: 700; font-size: 1.25em; }
  .incorrect { color: var(--red-color); font-weight: 700; font-size: 1.25em; }

  .chip {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.2em 0.8em;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 600;
    color: white;
    box-shadow: var(--shadow-sm);
  }
  .chip.Result-Green { background-color: var(--green-color); }
  .chip.Result-Red { background-color: var(--red-color); }
  .chip.Result-Violet { background-color: var(--violet-color); }
  .chip.Result-Big { background-color: var(--orange-color); }
  .chip.Result-Small { background-color: var(--blue-color); }
  .chip.Result-Pending, .chip.Result-null { background-color: #9ca3af; color: #fff; }
  .chip.Result-- { background-color: #9ca3af; color: #fff; }

  /* --- Performance & Streaks --- */
  .performance-streaks-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1rem;
  }
  .inner-section {
    background: #f9fafb;
    border: 1px solid var(--border-color);
    padding: 1rem;
    border-radius: var(--border-radius);
  }
  .inner-section h3 {
    font-size: 1rem;
    color: var(--accent-color);
    margin: 0 0 1rem 0;
    padding-bottom: 0.5rem;
    border-bottom: 1px dashed #d1d5db;
  }
  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 0.75rem;
  }
  .stat-card {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 0.75rem;
    text-align: center;
    box-shadow: var(--shadow-sm);
  }
  .stat-label {
    color: var(--secondary-text);
    font-weight: 500;
    margin-bottom: 0.25rem;
    font-size: 0.8rem;
  }
  .stat-value {
    font-weight: 700;
    font-size: 1.5rem;
    color: var(--primary-text);
  }
  .streak-detail-row {
    font-size: 0.9em;
    color: var(--secondary-text);
    margin-top: 0.2em;
    line-height: 1.3;
  }
  .streak-detail-row strong { color: var(--primary-text); font-weight: 600; }

  /* --- Raw JSON Dropdown --- */
  #raw-json-dropdown {
    font-size: 0.9rem;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    border: 1px solid #ccc;
    background-color: #f8f8f8;
    cursor: pointer;
  }
  #raw-json-display-wrapper {
    position: relative;
    margin-top: 1rem;
  }
  #raw-json-display {
    background: #1e293b;
    color: #e2e8f0;
    padding: 1.5rem;
    border-radius: 8px;
    overflow-x: auto;
    max-height: 300px;
    font-family: 'Fira Code', monospace;
    font-size: 0.875rem;
    white-space: pre-wrap;
    word-break: break-all;
  }
  #copy-json-btn {
    background: var(--accent-color);
    color: white;
    border: none;
    border-radius: 5px;
    padding: 0.4rem 0.8rem;
    cursor: pointer;
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: 0.8rem;
    transition: background 0.2s;
    opacity: 0.7;
  }
  #copy-json-btn:hover { background: var(--accent-hover); opacity: 1; }

  /* Error Message */
  .error-message {
    color: #b91c1c;
    background: #fee2e2;
    border: 1px solid #fca5a5;
    border-radius: var(--border-radius);
    padding: 1rem 1.5rem;
    margin-bottom: 1.5rem;
    text-align: center;
    font-weight: 500;
    display: none;
    box-shadow: var(--shadow-sm);
  }

  /* Responsive Adjustments */
  @media (max-width: 768px) {
    main { padding: 1rem; gap: 1rem; }
    .section { padding: 1rem; }
    h2 { font-size: 1.1rem; margin-bottom: 1rem; }
    header { padding: 0.75rem 1rem; flex-direction: column; align-items: flex-start; }
    .header-info { width: 100%; flex-direction: row; justify-content: space-between; align-items: center; }
    .grid-container { grid-template-columns: 1fr; }
  }
  @media (max-width: 480px) {
    .header-title { font-size: 1.2rem; }
    .main-prediction-details { flex-direction: column; align-items: stretch; gap: 1rem; }
    .pattern-pred-value { font-size: 2.25rem; min-width: auto; width: 100%; padding: 1rem; }
    #ai-prediction-value { font-size: 3rem; }
    th, td { padding: 0.5rem; }
  }
</style>
</head>
<body>

<header>
  <div class="header-title">Wingo 1 min Lottery Prediction Dashboard</div>
  <div class="header-info">
    <div id="timestamp-display">Last Updated: <span id="last-updated-time">--</span></div>
    <div id="countdown-timer">Next update in: --</div>
  </div>
</header>

<main>
  <div class="error-message" id="error-message"></div>

  <section class="section" id="current-prediction">
    <h2>Main Prediction (Draw #<span id="draw-number">--</span>) ✨</h2>
    <div style="text-align: center; color: var(--secondary-text); font-weight: 500;">Predicted Numbers & Likelihood</div>
    <div class="prediction-numbers" id="predicted-numbers">
      <div class="number-bubble">--</div>
    </div>
    <div class="main-prediction-details">
      <div class="prediction-detail-group">
        <div class="prediction-detail">Big / Small</div>
        <div class="prediction-value" id="predicted-big-small">--</div>
        <div class="percentages" id="big-small-percentages"></div>
      </div>
      <div class="prediction-detail-group">
        <div class="prediction-detail">Color</div>
        <div class="prediction-value" id="predicted-color">--</div>
        <div class="percentages" id="color-percentages"></div>
      </div>
    </div>
  </section>

  <div class="grid-container">
    <section class="section" id="color-prediction-section">
      <h2>Color Pattern Prediction 🎨</h2>
      <div class="pattern-prediction-box" id="color-prediction-display">
        <div class="pattern-pred-value Pending">Pending</div>
        <div class="pattern-pred-meta" id="color-prediction-meta">Awaiting data...</div>
      </div>
    </section>
    <section class="section" id="size-prediction-section">
      <h2>Size Pattern Prediction 📏</h2>
      <div class="pattern-prediction-box" id="size-prediction-display">
        <div class="pattern-pred-value Pending">Pending</div>
        <div class="pattern-pred-meta" id="size-prediction-meta">Awaiting data...</div>
      </div>
    </section>
  </div>
  
  <section class="section" id="sequence-analysis-section">
    <h2>Sequence Pattern Analysis 📈</h2>
    <div id="sequence-analysis">Loading sequence analysis...</div>
  </section>

  <div class="grid-container">
    <section class="section" id="ai-prediction-section">
        <h2>
          <span>AI Prediction 🧠</span>
          <button class="ai-toggle-btn" id="ai-toggle-btn" onclick="toggleAI()" aria-pressed="false" title="Enable or disable AI prediction">
            <span id="ai-toggle-btn-label">Start AI 🤖</span>
          </button>
        </h2>
        <div style="text-align:center;">
          <div id="ai-prediction-value">--</div>
          <div id="ai-prediction-display-badge"></div>
          <div id="ai-prediction-meta">
            Issue: <span id="ai-issue">--</span> | Last Run: <span id="ai-timestamp">--</span>
          </div>
        </div>
    </section>
    
    <section class="section" id="ai-big-small-accuracy-section">
        <h2>AI Big/Small Accuracy 📊</h2>
        <div style="text-align:center;">
          <div id="ai-big-small-accuracy-value">--</div>
          <div id="ai-big-small-accuracy-meta">
            Correct: <span id="ai-accuracy-correct">--</span> |
            Total: <span id="ai-accuracy-total">--</span> |
            Updated: <span id="ai-accuracy-timestamp">--</span>
          </div>
        </div>
    </section>
  </div>
  
  <section class="section" id="previous-draw-section">
      <div class="previous-draw" id="previous-draw">Loading...</div>
  </section>
  
  <div class="grid-container">
    <section class="section" id="color-history-section">
        <h2>Color Prediction History</h2>
        <div class="table-container">
          <table>
            <thead>
              <tr><th>Issue</th><th>Predicted</th><th>Rule</th><th>Actual</th><th>Result</th></tr>
            </thead>
            <tbody id="color-history-table-body">
              <tr><td colspan="5">Loading history...</td></tr>
            </tbody>
          </table>
        </div>
    </section>
    <section class="section" id="size-history-section">
        <h2>Size Prediction History</h2>
        <div class="table-container">
          <table>
            <thead>
              <tr><th>Issue</th><th>Predicted</th><th>Rule</th><th>Actual</th><th>Result</th></tr>
            </thead>
            <tbody id="size-history-table-body">
              <tr><td colspan="5">Loading history...</td></tr>
            </tbody>
          </table>
        </div>
    </section>
  </div>

  <section class="section" id="history-predictions">
    <h2>Main Prediction History</h2>
    <div class="table-container">
      <table>
        <thead>
          <tr><th>Draw #</th><th>Predicted</th><th>Actual</th><th>Num</th><th>B/S</th><th>Color</th></tr>
        </thead>
        <tbody id="history-table-body">
          <tr><td colspan="6">Loading main prediction data...</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <div class="grid-container">
    <section class="section" id="color-performance-section">
        <h2>Color Performance & Streaks</h2>
        <div id="color-performance-stats">
            <p>Loading performance data...</p>
        </div>
    </section>
    <section class="section" id="size-performance-section">
        <h2>Size Performance & Streaks</h2>
        <div id="size-performance-stats">
            <p>Loading performance data...</p>
        </div>
    </section>
  </div>
  
  <section class="section" id="past-performance-streaks">
    <h2>Main Performance & Streaks</h2>
    <div class="performance-streaks-container">
      <div class="inner-section">
        <h3>Accuracy</h3>
        <div class="stats-grid" id="accuracy-stats">
          <div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>
        </div>
      </div>
      <div class="inner-section">
        <h3>Streaks</h3>
        <div class="stats-grid" id="streaks-stats">
          <div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>
        </div>
      </div>
    </div>
  </section>

  <section class="section" id="raw-json-section">
    <h2>
      <span>Raw API Responses 👨‍💻</span>
      <select id="raw-json-dropdown" onchange="updateRawJsonDisplay()">
        <option value="prediction">Main Prediction</option>
        <option value="color_insights">Color Insights</option>
        <option value="size_insights">Size Insights</option>
        <option value="v2_insights">Combined Insights</option>
        <option value="ai_prediction">AI Prediction</option>
        <option value="ai_big_small_accuracy">AI B/S Accuracy</option>
        <option value="status">Status</option>
      </select>
    </h2>
    <div id="raw-json-display-wrapper">
      <pre id="raw-json-display">No data loaded yet.</pre>
      <button id="copy-json-btn" title="Copy JSON">Copy</button>
    </div>
  </section>
</main>

<script>
  // SCRIPT IS UNCHANGED AS PER REQUESTS.
  const NUM_TO_COLOR_MAP = {
    0: 'Red', 1: 'Green', 2: 'Red', 3: 'Green', 4: 'Red',
    5: 'Green', 6: 'Red', 7: 'Green', 8: 'Red', 9: 'Green'
  };
  const COLOR_MAP = {
    0: {primary: 'Red', secondary: 'Violet'}, 1: {primary: 'Green', secondary: null},
    2: {primary: 'Red', secondary: null}, 3: {primary: 'Green', secondary: null},
    4: {primary: 'Red', secondary: null}, 5: {primary: 'Green', secondary: 'Violet'},
    6: {primary: 'Red', secondary: null}, 7: {primary: 'Green', secondary: null},
    8: {primary: 'Red', secondary: null}, 9: {primary: 'Green', secondary: null}
  };

  function createChip(text, color) {
    const safeText = text ? String(text) : '';
    const safeColor = color ? String(color).toLowerCase() : 'gray';
    const validColors = ['red', 'green', 'violet', 'gray', 'blue', 'gold'];
    const finalColor = validColors.includes(safeColor) ? safeColor : 'gray';
    return `<span class="chip ${finalColor}">${safeText}</span>`;
  }
  
  function createHistoryChip(text, type) {
    const safeText = text ? String(text) : 'Pending';
    let safeType = safeText === 'Pending' ? 'Pending' : safeText;
    // The class name must be valid, e.g., Result-Red
    if (!type.startsWith('Result-')) {
        safeType = 'Result-' + safeType;
    } else {
        safeType = type;
    }
    return `<span class="chip ${safeType}">${safeText}</span>`;
  }

  function formatTimestamp(isoString) {
    try {
      if (!isoString) return '--';
      const date = new Date(isoString);
      if (isNaN(date.getTime())) throw new Error("Invalid date string");
      return date.toLocaleString('en-US', {
        month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true
      });
    } catch (e) {
      console.error("Error formatting timestamp:", e);
      return '-- Invalid --';
    }
  }

  let timerIntervalId = null;
  let countdownSeconds = 60;
  let lastApiTimestamp = null;
  
  const refreshTimes = [1.5, 5.0, 10.0, 58.5];

  let refreshGate = {
    '1.5': false,
    '5.0': false,
    '10.0': false,
    '58.5': false,
  };
  
  function checkRefreshTime() {
    const now = new Date();
    const currentSecond = now.getSeconds();
    const currentMs = now.getMilliseconds();
    
    if (currentSecond === 58 && currentMs >= 500 && !refreshGate['58.5']) {
      loadAllData();
      refreshGate['58.5'] = true;
    }
    if (currentSecond === 1 && currentMs >= 500 && !refreshGate['1.5']) {
      loadAllData();
      refreshGate['1.5'] = true;
    }
    if (currentSecond === 5 && currentMs >= 0 && currentMs <= 100 && !refreshGate['5.0']) {
      loadAllData();
      refreshGate['5.0'] = true;
    }
    if (currentSecond === 10 && currentMs >= 0 && currentMs <= 100 && !refreshGate['10.0']) {
      loadAllData();
      refreshGate['10.0'] = true;
    }
    
    if (currentMs < 100) {
      if (currentSecond !== 58 && refreshGate['58.5']) refreshGate['58.5'] = false;
      if (currentSecond !== 1 && refreshGate['1.5']) refreshGate['1.5'] = false;
      if (currentSecond !== 5 && refreshGate['5.0']) refreshGate['5.0'] = false;
      if (currentSecond !== 10 && refreshGate['10.0']) refreshGate['10.0'] = false;
    }
  }

  function updateCountdownDisplay() {
    if (!lastApiTimestamp) {
      document.getElementById('countdown-timer').textContent = "Next update in: -- s";
      return;
    }
    const now = new Date();
    const apiDate = new Date(lastApiTimestamp);
    let elapsedSeconds = Math.floor((now.getTime() - apiDate.getTime()) / 1000);
    if (elapsedSeconds < 0) elapsedSeconds = 0;
    
    let remaining = countdownSeconds - (elapsedSeconds % countdownSeconds);
    if (remaining <= 1 && elapsedSeconds > 0) {
      remaining = countdownSeconds;
    }
    document.getElementById('countdown-timer').textContent = `Next update in: ${remaining}s ⏳`;
  }

  function manualRefresh() {
    document.getElementById('countdown-timer').textContent = `Refreshing...`;
    loadAllData();
  }
  
  let rawApiResponses = { 
    prediction: null, 
    ai_prediction: null, 
    status: null, 
    ai_big_small_accuracy: null, 
    color_insights: null,
    size_insights: null,
    v2_insights: null
  };

  function updateRawJsonDisplay() {
    const dropdown = document.getElementById('raw-json-dropdown');
    const display = document.getElementById('raw-json-display');
    const selected = dropdown.value;
    const content = rawApiResponses[selected] ? JSON.stringify(rawApiResponses[selected], null, 2) : `No data for ${selected}.`;
    
    display.textContent = content;

    const copyBtn = document.getElementById('copy-json-btn');
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(content)
            .then(() => {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy', 1500);
            })
            .catch(err => console.error('Failed to copy text: ', err));
    };
  }

  let aiEnabled = false;

  async function fetchAIStatusAndUpdateBtn() {
    try {
      const res = await fetch('/api/ai/status');
      if (!res.ok) throw new Error('Failed to fetch AI status');
      const data = await res.json();
      aiEnabled = !!data.ai_enabled_flag;
    } catch (e) {
      aiEnabled = false;
      console.error("Error fetching AI status:", e);
      showErrorMessage("Failed to fetch AI status.");
    } finally {
      updateAIToggleBtn();
    }
  }

  function updateAIToggleBtn() {
    const btn = document.getElementById('ai-toggle-btn');
    const label = document.getElementById('ai-toggle-btn-label');
    const aiDisplayBadge = document.getElementById('ai-prediction-display-badge');
    if (!btn || !label || !aiDisplayBadge) return;
    if (aiEnabled) {
      btn.classList.add('active');
      label.textContent = 'Stop AI 🛑';
    } else {
      btn.classList.remove('active');
      label.textContent = 'Start AI 🤖';
      aiDisplayBadge.innerHTML = `<span class="ai-badge" disabled title="AI is OFF">AI OFF</span>`;
    }
  }

  async function toggleAI() {
    const endpoint = aiEnabled ? '/api/ai/stop' : '/api/ai/start';
    document.getElementById('ai-toggle-btn').disabled = true;
    try {
      const res = await fetch(endpoint, { method: 'POST' });
      if (!res.ok) throw new Error((await res.json()).message || 'Unknown error');
      const data = await res.json();
      aiEnabled = !!data.ai_enabled_flag;
      updateAIToggleBtn();
      loadAIPredictionData();
      loadAIBigSmallAccuracy();
    } catch (e) {
      showErrorMessage('Failed to toggle AI: ' + e.message);
    } finally {
      document.getElementById('ai-toggle-btn').disabled = false;
    }
  }

  function showErrorMessage(message) {
      const errorDiv = document.getElementById('error-message');
      errorDiv.textContent = message;
      errorDiv.style.display = "block";
      setTimeout(() => errorDiv.style.display = "none", 5000);
  }

  async function loadMainPredictionData() {
    try {
        const res = await fetch('/api/prediction');
        const data = await res.json();
        rawApiResponses['prediction'] = data;

        if (data.timestamp) {
            lastApiTimestamp = data.timestamp;
        }

        const prevDrawElem = document.getElementById('previous-draw');
        if (data.status === 'initializing') {
            prevDrawElem.innerHTML = `<span style="color: var(--secondary-text);">⏳ Main prediction system initializing...</span>`;
        } else if (data.status === 'error') {
            prevDrawElem.innerHTML = `<span style="color: var(--red-color);">❌ Error: ${data.message}</span>`;
        } else {
            const drawNumber = data.next_issue || data.issue || '--';
            const prediction = data.prediction || {};
            const predictedNumbers = prediction.predicted_likelihoods || [];
            const bigSmall = prediction.big_small || '--';
            const color = prediction.color || '--';

            document.getElementById('draw-number').textContent = String(drawNumber).slice(-4);
            
            const numbersContainer = document.getElementById('predicted-numbers');
            if (predictedNumbers && predictedNumbers.length > 0) {
                numbersContainer.innerHTML = '';
                [...predictedNumbers].sort((a, b) => b.likelihood - a.likelihood).forEach(item => {
                    const bubble = document.createElement('div');
                    bubble.className = 'number-bubble';
                    bubble.textContent = item.number;
                    if ([0, 2, 4, 6, 8].includes(item.number)) bubble.style.backgroundColor = 'var(--red-color)';
                    if ([1, 3, 5, 7, 9].includes(item.number)) bubble.style.backgroundColor = 'var(--green-color)';
                    if ([0, 5].includes(item.number)) bubble.style.borderColor = 'var(--violet-color)';
                    const pctDiv = document.createElement('div');
                    pctDiv.className = 'bubble-pct';
                    pctDiv.textContent = `${item.likelihood.toFixed(1)}%`;
                    bubble.appendChild(pctDiv);
                    numbersContainer.appendChild(bubble);
                });
            } else {
                numbersContainer.innerHTML = '<div class="number-bubble">--</div>';
            }

            document.getElementById('predicted-big-small').textContent = bigSmall;
            const bigSmallPercentages = document.getElementById('big-small-percentages');
            if (prediction.big_small_percentages) {
                bigSmallPercentages.innerHTML = Object.entries(prediction.big_small_percentages)
                    .map(([k, v]) => `<span>${k.replace('_percentage', '')}: ${v.toFixed(1)}%</span>`).join('');
            }

            document.getElementById('predicted-color').textContent = color;
            const colorPercentages = document.getElementById('color-percentages');
            if (prediction.color_percentages) {
                colorPercentages.innerHTML = Object.entries(prediction.color_percentages)
                    .map(([k, v]) => `<span>${k}: ${v.toFixed(1)}%</span>`).join('');
            }

            if (data.recent_results) {
                const recentIssues = Object.keys(data.recent_results).sort((a,b) => b.localeCompare(a));
                if (recentIssues.length > 0) {
                    const lastIssueKey = recentIssues[0];
                    const lastNum = data.recent_results[lastIssueKey];
                    const lastColor = NUM_TO_COLOR_MAP[lastNum] || '--';
                    const lastSize = lastNum >= 5 ? 'Big' : 'Small';
                    prevDrawElem.innerHTML = `Previous Draw #${String(lastIssueKey).slice(-4)}: <strong>${lastNum}</strong> (${lastColor}, ${lastSize})`;
                }
            } else {
                prevDrawElem.innerHTML = `Waiting for previous draw result...`;
            }

            const seqDiv = document.getElementById('sequence-analysis');
            if (data.sequence_analysis && data.sequence_analysis.length > 0) {
                seqDiv.innerHTML = data.sequence_analysis.map(item => `
                    <div style="margin-bottom:0.7em; padding-bottom: 0.7em; border-bottom: 1px solid var(--border-color);">
                        <p style="margin:0;"><b>Pattern [${item.pattern.join(', ')}]:</b> ${item.predictions.map(p => `<strong style="color:var(--accent-color);">${p.number}</strong>`).join(', ')}</p>
                        <p style="color:var(--secondary-text);font-size:0.9em;margin:0.2em 0 0;"><em>${item.message}</em></p>
                    </div>
                `).join('');
            } else { 
                seqDiv.innerHTML = '<p>No significant patterns detected.</p>'; 
            }

            updateMainPredictionHistory(data.prediction_history || []);
            updateMainPerformanceStats(data.accuracy, data.streaks);
        }

    } catch (err) {
        console.error("Failed to load main prediction data:", err);
        showErrorMessage(`Failed to load main prediction: ${err.message}`);
        document.getElementById('previous-draw').innerHTML = `<span style="color: var(--red-color);">❌ Failed to load main prediction data</span>`;
    }
  }

  function updateMainPredictionHistory(historyData) {
    const tbody = document.getElementById('history-table-body');
    if (!historyData || historyData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6">No main prediction history available.</td></tr>';
        return;
    }

    tbody.innerHTML = '';
    historyData.slice(0, 15).forEach(item => {
        const tr = document.createElement('tr');
        const pred = item.prediction || {};
        const res = item.result || {};
        const corr = item.correct || {};

        const predText = `<b>${pred.number ? pred.number.join('/') : '--'}</b><br>${pred.big_small || '--'}<br>${createHistoryChip(pred.color, `Result-${pred.color}`)}`;
        
        const actualNum = res.number !== undefined ? res.number : '--';
        const actualColors = (res.colors || []).filter(Boolean).map(c => createHistoryChip(c, `Result-${c}`)).join(' ');
        const actualBS = res.big_small || '--';
        
        const actualText = `<b>${actualNum}</b><br>${createHistoryChip(actualBS, `Result-${actualBS}`)}<br>${actualColors}`;

        tr.innerHTML = `
            <td>${String(item.issue).slice(-4)}</td>
            <td>${predText}</td>
            <td>${actualText}</td>
            <td class="${corr.number ? 'correct' : 'incorrect'}">${corr.number ? '✔' : '✘'}</td>
            <td class="${corr.big_small ? 'correct' : 'incorrect'}">${corr.big_small ? '✔' : '✘'}</td>
            <td class="${corr.color ? 'correct' : 'incorrect'}">${corr.color ? '✔' : '✘'}</td>
        `;
        tbody.appendChild(tr);
    });
  }

  function updateMainPerformanceStats(accuracyStats, streakStats) {
    const accuracyContainer = document.getElementById('accuracy-stats');
    const streaksContainer = document.getElementById('streaks-stats');

    if (accuracyStats) {
        const parsePercent = (str) => (str || "0%").match(/(\d+\.?\d*)/)?.[0] || "0";
        accuracyContainer.innerHTML = `
            <div class="stat-card"><div class="stat-label">Numbers</div><div class="stat-value">${parsePercent(accuracyStats.number_accuracy)}%</div></div>
            <div class="stat-card"><div class="stat-label">Color</div><div class="stat-value">${parsePercent(accuracyStats.color_accuracy)}%</div></div>
            <div class="stat-card"><div class="stat-label">Big/Small</div><div class="stat-value">${parsePercent(accuracyStats.big_small_accuracy)}%</div></div>
        `;
    } else {
        accuracyContainer.innerHTML = '<div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>';
    }

    if (streakStats) {
        streaksContainer.innerHTML = '';
        Object.entries(streakStats).forEach(([key, val]) => {
            const label = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            streaksContainer.innerHTML += `
                <div class="stat-card">
                    <div class="stat-label">${label} Streaks</div>
                    <div class="streak-detail-row">Win: <strong style="color:var(--green-color);">${val.current_win || 0}</strong> (Max: ${val.max_win || 0})</div>
                    <div class="streak-detail-row">Loss: <strong style="color:var(--red-color);">${val.current_loss || 0}</strong> (Max: ${val.max_loss || 0})</div>
                </div>
            `;
        });
    } else {
        streaksContainer.innerHTML = '<div class="stat-card"><div class="stat-label">Loading...</div><div class="stat-value">--</div></div>';
    }
  }

  async function loadColorInsightsData() {
    const predDisplay = document.getElementById('color-prediction-display');
    const perfStats = document.getElementById('color-performance-stats');
    const historyBody = document.getElementById('color-history-table-body');

    try {
        const res = await fetch('/api/color_insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['color_insights'] = data;

        const pred = data.color_prediction;
        if (pred && pred.next_color) {
            predDisplay.innerHTML = `
                <div class="pattern-pred-value ${pred.next_color}">${pred.next_color}</div>
                <div class="pattern-pred-meta" id="color-prediction-meta">
                    For Issue #<strong>${String(pred.issue).slice(-4)}</strong> based on <strong>${pred.rule_name || 'N/A'}</strong> (Score: ${pred.rule_score || 0}%)
                    <br>Sequence: <span class="pred-sequence-code">${pred.observed_sequence || 'N/A'}</span>
                    <br>Updated: ${formatTimestamp(pred.last_updated)}
                </div>
            `;
        } else {
            predDisplay.innerHTML = `<div class="pattern-pred-value Pending">Pending</div><div class="pattern-pred-meta" id="color-prediction-meta">No active color prediction.</div>`;
        }

        const acc = data.color_accuracy;
        const streaks = data.color_streaks;
        if (acc && streaks) {
            let perRuleHtml = 'No rule data.';
            if (acc.per_rule && Object.keys(acc.per_rule).length > 0) {
              perRuleHtml = `<div class="table-container"><table style="font-size:0.8rem;"><thead><tr><th>Rule</th><th>Acc.</th><th>Count</th></tr></thead><tbody>
                    ${Object.entries(acc.per_rule).sort(([,a],[,b]) => b.total - a.total).map(([rule, stats]) => `
                      <tr><td>${rule}</td><td>${stats.accuracy_pct.toFixed(1)}%</td><td>${stats.correct}/${stats.total}</td></tr>`).join('')}
                  </tbody></table></div>`;
            }
            
            perfStats.innerHTML = `<div class="performance-streaks-container">
              <div class="inner-section"><h3>Overall</h3><div class="stats-grid">
                <div class="stat-card"><div class="stat-label">Accuracy</div><div class="stat-value">${(acc.accuracy_percentage || 0).toFixed(1)}%</div></div>
                <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value">${acc.correct_predictions || 0}/${acc.total_predictions || 0}</div></div>
                <div class="stat-card"><div class="stat-label">Win Streak</div><div class="stat-value">${streaks.current_win_streak || 0}</div></div>
                <div class="stat-card"><div class="stat-label">Loss Streak</div><div class="stat-value">${streaks.current_lose_streak || 0}</div></div>
              </div></div>
              <div class="inner-section"><h3>Accuracy by Rule</h3>${perRuleHtml}</div>
            </div>`;
        } else {
            perfStats.innerHTML = '<p>No color performance data available.</p>';
        }

        const historyData = data.color_prediction_history;
        historyBody.innerHTML = '';
        if (historyData && historyData.length > 0) {
            historyData.forEach(item => {
                const actualColor = item.actual_color;
                const isCorrect = actualColor !== null && item.predicted_color === actualColor;
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${String(item.issue).slice(-4)}</td>
                    <td>${createHistoryChip(item.predicted_color, 'Result-'+item.predicted_color)}</td>
                    <td>${item.rule_name || 'N/A'}</td>
                    <td>${createHistoryChip(actualColor, 'Result-'+actualColor)}</td>
                    <td class="${actualColor ? (isCorrect ? 'correct' : 'incorrect') : ''}">
                        ${actualColor ? (isCorrect ? '✔' : '✘') : '?'}
                    </td>
                `;
                historyBody.appendChild(tr);
            });
        } else {
            historyBody.innerHTML = '<tr><td colspan="5">No color prediction history available.</td></tr>';
        }

    } catch (err) {
        console.error("Failed to load color insights:", err);
        showErrorMessage(`Failed to load Color Insights: ${err.message}`);
        predDisplay.innerHTML = `<div class="pattern-pred-value Pending">Error</div><div class="pattern-pred-meta" id="color-prediction-meta">Could not fetch color data.</div>`;
        perfStats.innerHTML = '<p>Error loading performance data.</p>';
        historyBody.innerHTML = '<tr><td colspan="5">Error loading history.</td></tr>';
    }
  }

  async function loadSizeInsightsData() {
    const predDisplay = document.getElementById('size-prediction-display');
    const perfStats = document.getElementById('size-performance-stats');
    const historyBody = document.getElementById('size-history-table-body');

    try {
        const res = await fetch('/api/size_insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['size_insights'] = data;

        const pred = data.size_prediction;
        if (pred && pred.next_size) {
            predDisplay.innerHTML = `
                <div class="pattern-pred-value ${pred.next_size}">${pred.next_size}</div>
                <div class="pattern-pred-meta" id="size-prediction-meta">
                    For Issue #<strong>${String(pred.issue).slice(-4)}</strong> based on <strong>${pred.rule_name || 'N/A'}</strong> (Score: ${pred.rule_score || 0}%)
                    <br>Sequence: <span class="pred-sequence-code">${pred.observed_sequence || 'N/A'}</span>
                    <br>Updated: ${formatTimestamp(pred.last_updated)}
                </div>
            `;
        } else {
            predDisplay.innerHTML = `<div class="pattern-pred-value Pending">Pending</div><div class="pattern-pred-meta" id="size-prediction-meta">No active size prediction.</div>`;
        }

        const acc = data.size_accuracy;
        const streaks = data.size_streaks;
        if (acc && streaks) {
            let perRuleHtml = 'No rule data.';
            if (acc.per_rule && Object.keys(acc.per_rule).length > 0) {
              perRuleHtml = `<div class="table-container"><table style="font-size:0.8rem;"><thead><tr><th>Rule</th><th>Acc.</th><th>Count</th></tr></thead><tbody>
                    ${Object.entries(acc.per_rule).sort(([,a],[,b]) => b.total - a.total).map(([rule, stats]) => `
                      <tr><td>${rule}</td><td>${stats.accuracy_pct.toFixed(1)}%</td><td>${stats.correct}/${stats.total}</td></tr>`).join('')}
                  </tbody></table></div>`;
            }

            perfStats.innerHTML = `<div class="performance-streaks-container">
              <div class="inner-section"><h3>Overall</h3><div class="stats-grid">
                <div class="stat-card"><div class="stat-label">Accuracy</div><div class="stat-value">${(acc.accuracy_percentage || 0).toFixed(1)}%</div></div>
                <div class="stat-card"><div class="stat-label">Total</div><div class="stat-value">${acc.correct_predictions || 0}/${acc.total_predictions || 0}</div></div>
                <div class="stat-card"><div class="stat-label">Win Streak</div><div class="stat-value">${streaks.current_win_streak || 0}</div></div>
                <div class="stat-card"><div class="stat-label">Loss Streak</div><div class="stat-value">${streaks.current_lose_streak || 0}</div></div>
              </div></div>
              <div class="inner-section"><h3>Accuracy by Rule</h3>${perRuleHtml}</div>
            </div>`;
        } else {
            perfStats.innerHTML = '<p>No size performance data available.</p>';
        }

        const historyData = data.size_prediction_history;
        historyBody.innerHTML = '';
        if (historyData && historyData.length > 0) {
            historyData.forEach(item => {
                const actualSize = item.actual_size;
                const isCorrect = actualSize !== null && item.predicted_size === actualSize;
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${String(item.issue).slice(-4)}</td>
                    <td>${createHistoryChip(item.predicted_size, 'Result-'+item.predicted_size)}</td>
                    <td>${item.rule_name || 'N/A'}</td>
                    <td>${createHistoryChip(actualSize, 'Result-'+actualSize)}</td>
                    <td class="${actualSize ? (isCorrect ? 'correct' : 'incorrect') : ''}">
                        ${actualSize ? (isCorrect ? '✔' : '✘') : '?'}
                    </td>
                `;
                historyBody.appendChild(tr);
            });
        } else {
            historyBody.innerHTML = '<tr><td colspan="5">No size prediction history available.</td></tr>';
        }

    } catch (err) {
        console.error("Failed to load size insights:", err);
        showErrorMessage(`Failed to load Size Insights: ${err.message}`);
        predDisplay.innerHTML = `<div class="pattern-pred-value Pending">Error</div><div class="pattern-pred-meta" id="size-prediction-meta">Could not fetch size data.</div>`;
        perfStats.innerHTML = '<p>Error loading performance data.</p>';
        historyBody.innerHTML = '<tr><td colspan="5">Error loading history.</td></tr>';
    }
  }

  async function loadAIPredictionData() {
    const valElem = document.getElementById('ai-prediction-value');
    const issueElem = document.getElementById('ai-issue');
    const tsElem = document.getElementById('ai-timestamp');
    const badgeElem = document.getElementById('ai-prediction-display-badge');

    valElem.textContent = '--'; issueElem.textContent = '--'; tsElem.textContent = '--';
    if (!aiEnabled) { badgeElem.innerHTML = `<span class="ai-badge" disabled>AI OFF</span>`; return; }
    badgeElem.innerHTML = `<span class="ai-badge">Fetching...</span>`;

    try {
        const res = await fetch('/api/ai_prediction');
        const data = await res.json();
        rawApiResponses['ai_prediction'] = data;
        if (data.status === 'no_data' || data.ai_prediction === undefined) {
            badgeElem.innerHTML = `<span class="ai-badge" disabled>No Data</span>`;
        } else {
            const predNum = parseInt(data.ai_prediction);
            valElem.textContent = predNum;
            issueElem.textContent = String(data.issue).slice(-4);
            tsElem.textContent = formatTimestamp(data.timestamp);
            badgeElem.innerHTML = `<span class="ai-badge">Active</span>`;
            valElem.style.color = 'var(--accent-color)';
            valElem.style.textShadow = 'none';
            if (!isNaN(predNum)) {
                if ([0, 2, 4, 6, 8].includes(predNum)) valElem.style.color = 'var(--red-color)';
                if ([1, 3, 5, 7, 9].includes(predNum)) valElem.style.color = 'var(--green-color)';
                if ([0, 5].includes(predNum)) valElem.style.textShadow = '0 0 10px var(--violet-color)';
            }
        }
    } catch (err) {
        showErrorMessage(`Failed to load AI data: ${err.message}`);
        badgeElem.innerHTML = `<span class="ai-badge" disabled>Failed</span>`;
    }
  }

  async function loadAIBigSmallAccuracy() {
    const valElem = document.getElementById('ai-big-small-accuracy-value');
    const tsElem = document.getElementById('ai-accuracy-timestamp');
    const correctElem = document.getElementById('ai-accuracy-correct');
    const totalElem = document.getElementById('ai-accuracy-total');

    valElem.textContent = '--'; tsElem.textContent = '--'; correctElem.textContent = '--'; totalElem.textContent = '--';
    if (!aiEnabled) return;

    try {
        const res = await fetch('/api/ai_big_small_accuracy');
        const data = await res.json();
        rawApiResponses['ai_big_small_accuracy'] = data;
        if (data.status === 'success' && data.accuracy !== undefined) {
            valElem.textContent = `${data.accuracy.toFixed(2)}%`;
            correctElem.textContent = data.correct_predictions;
            totalElem.textContent = data.total_predictions;
            tsElem.textContent = formatTimestamp(data.timestamp);
        } else {
            valElem.textContent = 'N/A';
        }
    } catch (err) {
        showErrorMessage(`Failed to load AI B/S accuracy: ${err.message}`);
        valElem.textContent = 'Error';
    }
  }

  async function loadCombinedInsightsData() {
    try {
        const res = await fetch('/api/v2/insights');
        if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
        const data = await res.json();
        rawApiResponses['v2_insights'] = data;
    } catch (err) {
        console.error("Failed to load combined insights:", err);
    }
  }

  async function loadAllData() {
    try {
        document.getElementById('last-updated-time').textContent = formatTimestamp(new Date().toISOString());
        
        await Promise.all([
            loadMainPredictionData(),           
            loadColorInsightsData(),
            loadSizeInsightsData(),
            loadCombinedInsightsData(),
            fetchAIStatusAndUpdateBtn().then(() => {
                return Promise.all([
                    loadAIPredictionData(),
                    loadAIBigSmallAccuracy()
                ]);
            })
        ]);
        
        updateRawJsonDisplay();
        
    } catch (err) {
        console.error("Error loading data:", err);
        showErrorMessage(`Error loading dashboard data: ${err.message}`);
    }
  }

  function init() {
    loadAllData();
    
    timerIntervalId = setInterval(() => {
        checkRefreshTime();
    }, 100);

    setInterval(updateCountdownDisplay, 1000);
  }

  window.onload = init;
</script>

</body>
</html>
